#include "clang/AST/AST.h"
#include "clang/AST/RecursiveASTVisitor.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Frontend/FrontendActions.h"
#include "clang/Rewrite/Core/Rewriter.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"

using namespace clang;
using namespace clang::tooling;

static llvm::cl::OptionCategory SplitStructCategory("split-struct options");

// Decide "hot" vs "cold" by field name (you can tweak this)
static bool isHotField(const FieldDecl *F) {
    auto Name = F->getName();
    return (Name == "price" ||
            Name == "size" ||
            Name == "order_count");
}

class SplitVisitor : public RecursiveASTVisitor<SplitVisitor> {
public:
    SplitVisitor(ASTContext &C, Rewriter &R)
        : Ctx(C), RW(R) {}

    bool VisitRecordDecl(RecordDecl *RD) {
        if (!RD->isStruct() || !RD->isThisDeclarationADefinition())
            return true;

        // Only target struct OrderBookLevel with [[clang::annotate("hft_struct")]]
        bool annotated = false;
        for (auto *A : RD->attrs()) {
            if (auto *Ann = dyn_cast<AnnotateAttr>(A)) {
                if (Ann->getAnnotation() == "hft_struct") {
                    annotated = true;
                    break;
                }
            }
        }
        if (!annotated)
            return true;

        IdentifierInfo *II = RD->getIdentifier();
        if (!II)
            return true;
        if (II->getName() != "OrderBookLevel")
            return true;

        splitStruct(RD);
        return true;
    }

private:
    ASTContext &Ctx;
    Rewriter &RW;

    void splitStruct(RecordDecl *RD) {
        std::string hotFields;
        std::string coldFields;

        for (auto *F : RD->fields()) {
            std::string T = F->getType().getAsString();
            std::string N = F->getNameAsString();

            if (isHotField(F)) {
                hotFields += "    " + T + " " + N + ";\n";
            } else {
                coldFields += "    " + T + " " + N + ";\n";
            }
        }

        std::string hotStruct =
            "\n// AUTO-GENERATED by split_struct: hot fields of OrderBookLevel\n"
            "struct HotLevel {\n" +
            hotFields +
            "};\n";

        std::string coldStruct =
            "\n// AUTO-GENERATED by split_struct: cold fields of OrderBookLevel\n"
            "struct ColdLevel {\n" +
            coldFields +
            "};\n";

        // Insert AFTER the original struct definition so OrderBookLevel still exists
        SourceLocation InsertLoc = RD->getSourceRange().getEnd();
        InsertLoc = Lexer::getLocForEndOfToken(
            InsertLoc, 0, RW.getSourceMgr(), Ctx.getLangOpts());

        RW.InsertTextAfter(InsertLoc, hotStruct + coldStruct);
    }
};

class SplitASTConsumer : public ASTConsumer {
public:
    SplitASTConsumer(ASTContext &C, Rewriter &R)
        : Visitor(C, R) {}

    void HandleTranslationUnit(ASTContext &Ctx) override {
        Visitor.TraverseDecl(Ctx.getTranslationUnitDecl());
    }

private:
    SplitVisitor Visitor;
};

class SplitFrontendAction : public ASTFrontendAction {
public:
    SplitFrontendAction() {}

    std::unique_ptr<ASTConsumer> CreateASTConsumer(
        CompilerInstance &CI, StringRef InFile) override {
        RW.setSourceMgr(CI.getSourceManager(), CI.getLangOpts());
        return std::make_unique<SplitASTConsumer>(CI.getASTContext(), RW);
    }

    void EndSourceFileAction() override {
        auto &SM = RW.getSourceMgr();
        RW.getEditBuffer(SM.getMainFileID()).write(llvm::outs());
    }

private:
    Rewriter RW;
};

int main(int argc, const char **argv) {
    auto ExpectedParser =
        CommonOptionsParser::create(argc, argv, SplitStructCategory);
    if (!ExpectedParser) {
        llvm::errs() << llvm::toString(ExpectedParser.takeError()) << "\n";
        return 1;
    }

    CommonOptionsParser &Options = ExpectedParser.get();

    ClangTool Tool(Options.getCompilations(), Options.getSourcePathList());

    // Default flags if there is no compile_commands.json
    Tool.appendArgumentsAdjuster(
        getInsertArgumentAdjuster("-std=c++17", ArgumentInsertPosition::END));
    Tool.appendArgumentsAdjuster(
        getInsertArgumentAdjuster("-I/usr/include", ArgumentInsertPosition::END));
    Tool.appendArgumentsAdjuster(
        getInsertArgumentAdjuster("-I/usr/include/c++/12", ArgumentInsertPosition::END));
    Tool.appendArgumentsAdjuster(
        getInsertArgumentAdjuster("-I/usr/lib/gcc/x86_64-linux-gnu/12/include",
                                  ArgumentInsertPosition::END));

    return Tool.run(newFrontendActionFactory<SplitFrontendAction>().get());
}
